# 高性能 DEX L2 的 Fault Proof 设计

## 1. 背景

### 1.1 对标项目：Hyperliquid

本方案对标 **Hyperliquid**，一个高性能去中心化永续合约交易所。

| 特性 | Hyperliquid | 说明 |
|------|-------------|------|
| 定位 | 独立 L1 | 自建区块链，非 L2 |
| 共识 | HyperBFT (PoS) | BFT 变体，Validator 共识 |
| TPS | 10 万+ (声称) | 极高吞吐量 |
| 出块 | ~0.2-0.5 秒 | 亚秒级 |
| EVM | ❌ 不兼容 | 自定义 VM |
| 状态存储 | 无 MPT (推测) | 纯 KV 存储，无 Merkle 化 |
| 安全模型 | PoS Validators | 依赖 Validator 诚实 |

**Hyperliquid 为什么能做到高 TPS？**

```
核心原因: 它是独立 L1，不需要向任何人"证明"状态

┌─────────────────────────────────────────────────────────────────┐
│ Hyperliquid 安全模型:                                           │
│                                                                 │
│   用户 → 信任 PoS Validators → 如果作恶只能 slash              │
│                                                                 │
│   不需要 MPT (无需生成状态证明)                                  │
│   不需要 ZK Proof (无需向 L1 证明)                              │
│   不需要 Fault Proof (无需挑战机制)                             │
│                                                                 │
│   代价: 安全性完全依赖 Validator 集合的诚实                      │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 本方案目标：L2 + 高性能

**我们的目标**：既要 Hyperliquid 的高性能，又要 L2 的安全性。

| 指标 | Hyperliquid | 本方案目标 | 差异 |
|------|-------------|-----------|------|
| TPS | 10 万+ | **10 万 TPS** | 相同 |
| 出块 | ~0.2s | **0.1 秒** | 更快 |
| 安全模型 | PoS 信任 | **L2 (继承 L1)** | 更安全 |
| 状态证明 | ❌ 不需要 | **✅ 需要** | 核心挑战 |

**核心矛盾**：
- 高 TPS 需要轻量级设计（无 MPT）
- L2 安全需要状态证明（传统上依赖 MPT）

### 1.3 设计参数

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 出块速度 | 0.1 秒 | 极高频率 |
| 交易量 | 1,000-10,000 笔/区块 | 高吞吐 |
| 吞吐量 | **10 万 TPS** | 对标 Hyperliquid |
| 状态存储 | 无 MPT | 性能优化 |
| 安全模型 | L2 (继承 L1) | 比 Hyperliquid 更安全 |

### 1.5 当前架构

```
区块结构:
┌─────────────────────────────────────────────┐
│ Block N                                     │
│  ├── prev_hash                              │
│  ├── transactions[1000]                     │
│  └── output_hash = H(prev_hash, block_data) │
└─────────────────────────────────────────────┘

状态存储:
┌─────────────────────────────────────────────┐
│ Database (LevelDB/RocksDB)                  │
│  ├── accounts: map[address] → balance       │
│  ├── storage: map[address][key] → value     │
│  └── 无 Merkle 化，纯 KV 存储               │
└─────────────────────────────────────────────┘
```

### 1.6 为什么不用 MPT？

| 操作 | MPT 开销 | 说明 |
|------|---------|------|
| 单次状态更新 | O(log n) 哈希计算 | ~10-20 次哈希 |
| 每区块 1000 笔交易 | 1000 × O(log n) | 大量 CPU 开销 |
| 0.1 秒出块 | 需要 < 100ms 完成 | MPT 可能成为瓶颈 |

### 1.7 核心诉求

**优先级排序**：

| 优先级 | 诉求 | 说明 |
|--------|------|------|
| **P0** | 性能优先 | 不让 MPT 成为瓶颈，保证 10 万 TPS |
| **P1** | 安全保证 | 可接受 ZK / Fault Proof 等任何技术 |
| **P2** | 终局性延迟 | 可接受 **1 天以上** |

**这意味着什么？**

```
┌─────────────────────────────────────────────────────────────────┐
│ P0 性能优先:                                                    │
│   → 出块时不做 MPT 计算                                         │
│   → 状态用简单 KV 存储                                          │
│   → 0.1 秒出块，10 万 TPS                                       │
├─────────────────────────────────────────────────────────────────┤
│ P1 安全保证:                                                    │
│   → 不依赖纯 PoS 信任                                           │
│   → 需要某种形式的状态验证 (ZK 或 Fault Proof)                  │
│   → 安全性继承自验证机制，而非 Validator 诚实                   │
├─────────────────────────────────────────────────────────────────┤
│ P2 可接受 1 天+ 延迟:                                           │
│   → 不需要分钟级终局性                                          │
│   → 可以用更长的 ZK 批量周期                                    │
│   → 可以用 7 天挑战期的 Fault Proof                             │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 问题分析

### 2.1 核心问题

**没有 MPT，如何在 L1 上验证 L2 状态转换的正确性？**

### 2.2 为什么 Fault Proof 需要状态证明？

区块链执行是**有状态**的：

```
示例：用户 A 转账 100 给 B

执行前状态:
  A.balance = ???  ← 必须知道这个值
  B.balance = ???

执行逻辑:
  require(A.balance >= 100)  ← 需要验证
  A.balance -= 100
  B.balance += 100
```

**链上验证需要证明 "执行前 A 的余额是 100"**

### 2.3 有 MPT vs 无 MPT

| 场景 | 有 MPT | 无 MPT |
|------|--------|--------|
| 证明 A.balance = 100 | Merkle Proof (~1KB) | 提交整个数据库 (~GB) |
| 验证成本 | O(log n) | O(n) |
| 链上可行性 | ✅ 可行 | ❌ 不可行 |

### 2.4 结论

**没有某种形式的状态承诺，无论是 Fault Proof 还是 ZK Proof 都无法工作。**

| 验证方式 | 是否需要状态承诺 | 状态验证位置 | 说明 |
|---------|----------------|-------------|------|
| Fault Proof | ✅ 需要 MPT/SMT | 链上 | 需要提交 Merkle Proof |
| ZK Proof | ✅ 仍需要 SMT | 链下 | Prover 需要状态承诺来生成 proof |

**区别**：
- **Fault Proof**：状态验证在链上完成，需要提交 Merkle Proof 到 L1
- **ZK Proof**：状态验证在链下完成，L1 只验证 proof 的数学正确性

**我们的方案（D）**：
- 热路径（出块）：不做状态承诺，保证 10 万 TPS 性能
- 冷路径（结算）：异步构建 SMT，用于 ZK 证明和 L1 验证

---

## 3. 解决方案

| 方案 | 需要状态承诺? | 需要 ZK? | 终局性 | 适合 10 万 TPS? |
|------|-------------|----------|--------|----------------|
| **A: 纯 ZK 批量证明** | ⚠️ 需要（隐含） | ✅ 每 batch | 分钟级 | ❌ 成本太高 |
| **B: Fault Proof + 异步 SMT** | ✅ 异步 SMT | ⚠️ 被挑战时 | 7 天 | ✅ **推荐** |
| **C: State Diff Commitment** | ✅ 每区块 Merkle | ❌ | 7 天 | ❌ 性能不足 |

---

### 3.1 方案 A: 纯 ZK 批量证明

**核心思想**：链下生成 ZK 证明，链上只验证 proof，不需要状态数据。

```
┌─────────────────────────────────────────────────────────────────┐
│                         链下 (Prover)                            │
│                                                                 │
│  输入:                                                          │
│    - prev_state (完整状态，存在 prover 本地)                     │
│    - blocks[N..N+1000] (1000 个区块，100 秒的交易)              │
│                                                                 │
│  执行:                                                          │
│    for block in blocks:                                         │
│      new_state = execute(prev_state, block.transactions)        │
│      prev_state = new_state                                     │
│                                                                 │
│  输出:                                                          │
│    - ZK Proof 证明 prev_hash → new_hash 的转换正确              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         链上 (Verifier)                          │
│                                                                 │
│  验证: verify(proof, prev_hash, new_hash) == true               │
│  不需要知道任何状态细节！                                        │
│                                                                 │
│  Gas 成本: ~200k (固定)                                         │
└─────────────────────────────────────────────────────────────────┘
```

#### 性能分析（1 万 TPS）

```
当前 ZK 证明能力:
  - SP1 zkVM: ~1,000-5,000 TPS
  - 假设: 2,000 TPS

你的场景:
  - 吞吐量: 10,000 TPS
  - 每秒产生交易: 10,000 笔
  - 每秒证明能力: 2,000 笔

追赶能力:
  - 单 prover: 追不上 (2,000 < 10,000)
  - 5 台 prover 并行: 刚好追上 (5 × 2,000 = 10,000)
  - 10 台 prover: 有余量
```

#### 批量证明策略

| 批量大小 | 时间跨度 | 交易量 | Prover 需求 | 终局性延迟 |
|----------|---------|--------|-------------|-----------|
| 100 区块 | 10 秒 | 10 万笔 | ~5 台 | ~1 分钟 |
| 1000 区块 | 100 秒 | 100 万笔 | ~5 台 | ~3 分钟 |
| 6000 区块 | 10 分钟 | 600 万笔 | ~5 台 | ~15 分钟 |

**推荐配置**：
- 批量大小: 1000 区块 (100 秒)
- Prover 数量: 5-10 台
- 终局性延迟: 3-5 分钟

#### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 不需要 MPT | ❌ **成本太高 (~$33.6M/天)** |
| ✅ 链上验证成本固定 | ❌ 需要 prover 集群持续运行 |
| ✅ 分钟级终局性 | ❌ ZK 基础设施成本 |
| | ⚠️ 需要状态承诺来锚定 prev_hash |

**成本分析**：
```
每笔证明成本: $0.00038909
每 batch (1 亿笔): 1 亿 × $0.00038909 = $38,910
每天 (864 batch): $33,600,000 ❌ 不可行
```

**结论**：方案 A (Validity 模式) 在 10 万 TPS 场景下成本不可接受，不推荐。

---

### 3.2 方案 B: Fault Proof + 异步 SMT（推荐）

**核心思想**：乐观执行 + 异步状态承诺。正常情况只提交 output_hash + smt_root，被挑战时才生成 ZK 证明。

```
为什么推荐:
┌─────────────────────────────────────────────────────────────────┐
│ 1. 成本极低: 正常情况不需要 ZK 证明，只有 L1 提交成本            │
│ 2. 性能保证: 热路径不做 SMT，支持 10 万 TPS                      │
│ 3. 安全性: 异步 SMT 提供状态承诺，被挑战时可验证                 │
│ 4. 终局性: 7 天（符合你的要求：可接受 1 天+ 延迟）               │
└─────────────────────────────────────────────────────────────────┘
```

#### 核心流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    正常情况 (99%+ 的时间)                         │
│                                                                 │
│  1. 出块: 0.1s/区块，不做 SMT                                   │
│  2. 异步更新 SMT: 每 batch (100s) 更新一次                      │
│  3. 提交 L1: output_hash + smt_root (无 ZK proof!)              │
│  4. 等待挑战期 (7 天)                                           │
│  5. 无人挑战 → 自动确认                                         │
│                                                                 │
│  成本: 只有 L1 提交                                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    有挑战的情况 (<1%)                             │
│                                                                 │
│  1. Challenger 发现问题，提交挑战 + 质押 bond                    │
│  2. Proposer 生成 ZK 证明:                                      │
│     - 输入: prev_smt_root, RW log, SMT proofs, blocks_data      │
│     - 证明: 从 prev_smt_root 执行交易得到 smt_root              │
│  3. L1 验证 ZK proof:                                           │
│     - 证明有效 → Proposer 获胜，获得 challenger 的 bond         │
│     - 未提交/无效 → Challenger 获胜                             │
│                                                                 │
│  成本: ~$38,910/batch (极少发生)                                │
└─────────────────────────────────────────────────────────────────┘
```

#### 架构设计

```
时间线:
┌─────────────────────────────────────────────────────────────────┐
│ 0s    100s   200s   300s   ...                                  │
│ │      │      │      │                                          │
│ ▼      ▼      ▼      ▼                                          │
│ B0     B1     B2     B3    ...  (出块，不做 SMT)                 │
│ │      │      │      │                                          │
│ ▼      ▼      ▼      ▼                                          │
│ SMT_0  SMT_1  SMT_2  SMT_3  ...  (异步更新 SMT)                  │
│ │      │      │      │                                          │
│ ▼      ▼      ▼      ▼                                          │
│ 提交L1 提交L1 提交L1 提交L1  ...  (output_hash + smt_root)       │
│ │      │      │      │          (无 ZK proof!)                  │
│ ▼      ▼      ▼      ▼                                          │
│ 7天后  7天后  7天后  7天后  ...  (自动确认，如无挑战)             │
└─────────────────────────────────────────────────────────────────┘
```

#### 关键设计点

**1. 出块时不做 SMT（性能保证）**

```
每个区块 (0.1s):
┌─────────────────────────────────────────────────────────────────┐
│ 1. 执行交易，更新内存 KV 存储                                     │
│ 2. 记录 RW log (哪些账户被读写)                                  │
│ 3. 计算 block_hash = H(prev_hash, txs_hash)                     │
│ 4. **不计算 SMT！不影响出块性能！**                                │
│                                                                 │
│ 总耗时: ~60-90ms < 100ms ✅                                     │
└─────────────────────────────────────────────────────────────────┘
```

**2. 异步 SMT 更新（每 100 秒）**

```
每个 batch (100秒):
┌─────────────────────────────────────────────────────────────────┐
│ 阶段 1: 汇总 RW Log                                              │
│   1. 从所有区块收集 RW log                                        │
│   2. 汇总 touched_keys = union(read_set.keys, write_set.keys)    │
│   3. 去重后: ~200 万账户                                          │
│                                                                 │
│ 阶段 2: 异步更新 SMT (后台线程)                                   │
│   1. 增量更新 SMT，只更新 touched_keys                           │
│   2. 200 万账户 × 256 层 = 5.12 亿次哈希                         │
│   3. 16 核并行: ~16-32 秒 ✅                                     │
│   4. 计算新的 smt_root                                           │
│                                                                 │
│ 阶段 3: 提交到 L1 (无 ZK proof!)                                 │
│   1. output_hash (区块链 hash)                                   │
│   2. smt_root (状态承诺)                                         │
│   3. 等待 7 天挑战期                                              │
└─────────────────────────────────────────────────────────────────┘
```

**3. 被挑战时生成 ZK Proof**

```
挑战发生时:
┌─────────────────────────────────────────────────────────────────┐
│ 1. 生成 SMT Proofs (涉及账户)                                    │
│    - 为 touched_keys 生成 SMT proofs                             │
│    - 200 万账户 × 8KB = 16 GB → 压缩后 ~4-8 GB                   │
│                                                                 │
│ 2. 生成 ZK Proof                                                │
│    - 输入: prev_smt_root, RW log, SMT proofs, blocks_data        │
│    - 证明: 从 prev_smt_root 执行交易得到 smt_root                │
│    - 时间: ~5-10 分钟                                            │
│    - 成本: ~$38,910/batch                                        │
│                                                                 │
│ 3. 提交到 L1 验证                                                │
│    - verify(proof, prev_smt_root, smt_root) == true              │
│    - 验证通过 → Proposer 获胜                                    │
└─────────────────────────────────────────────────────────────────┘
```

**4. 为什么用 SMT 而不是 MPT？**

| 特性 | MPT | SMT |
|------|-----|-----|
| 树深度 | 可变（复杂） | 固定 256 层（简单） |
| 账户定位 | 需要遍历 | 直接索引（地址→位置） |
| 并行更新 | 困难（路径冲突） | 容易（路径独立） |
| 更新速度 | 慢 | 快（固定深度） |
| ZK 友好性 | 一般 | 更好 |

**5. RW Log（读写集记录）**

```
为什么需要 RW Log:
┌─────────────────────────────────────────────────────────────────┐
│ ZK 证明需要 witness，但如何知道"哪些账户被读写了"？                │
│                                                                 │
│ 有了 RW log:                                                     │
│   - 精确知道哪些账户被读写                                        │
│   - 只对这些账户生成 SMT proof                                   │
│   - Witness 大小可控                                            │
└─────────────────────────────────────────────────────────────────┘

实现方式:
┌─────────────────────────────────────────────────────────────────┐
│ 每笔交易执行时记录:                                               │
│   read_set = [{ key: "account:0x1234", value: 1000 }, ...]      │
│   write_set = [{ key: "account:0x1234", value: 900 }, ...]      │
│                                                                 │
│ 每个 batch 汇总:                                                 │
│   touched_keys = union(read_set.keys, write_set.keys)           │
│   - 去重后: ~200 万账户（而非 1 亿）                             │
└─────────────────────────────────────────────────────────────────┘
```

#### 成本分析

```
被挑战时 (<1%):
┌─────────────────────────────────────────────────────────────────┐
│ 单个 batch ZK 证明: ~$38,910                                    │
│ 但这是极少发生的情况                                             │
│ 且 challenger 需要质押 bond，错误挑战会损失                       │
└─────────────────────────────────────────────────────────────────┘

对比 Validity 模式:
┌─────────────────────────────────────────────────────────────────┐
│ Fault Proof: $8,640/天 (正常情况)                               │
│ Validity:    $33,600,000/天 (每 batch 都证明)                   │
│ 节省:        3890 倍 ✅                                          │
└─────────────────────────────────────────────────────────────────┘
```

#### 性能分析（10 万 TPS）

**出块性能**：
```
每区块: 10,000 笔交易
出块时间: 0.1 秒
TPS: 100,000

出块时:
  - 执行交易: ~50-80ms
  - 更新内存 KV: ~5-10ms
  - 记录 RW log: ~1-2ms
  - 计算 block_hash: ~1ms
  - 总计: ~60-90ms < 100ms ✅
  - 不做 SMT，性能不受影响 ✅
```

**SMT 更新性能**：
```
每 100 秒 (1 batch):
  - 涉及账户: 100,000 TPS × 2 账户/交易 × 100s = 2000 万账户
  - 实际去重后: ~200 万账户
  - SMT 更新: 200 万 × 256 = 5.12 亿次哈希
  - 16 核并行: ~16-32 秒 ✅
  - 有 100 秒时间，完全足够 ✅
```

#### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 正常情况无 ZK 证明成本 | ❌ 终局性延迟长 (7 天) |
| ✅ 出块性能不受影响（热路径无 SMT） | ❌ 需要异步 SMT 更新机制 |
| ✅ 支持 10 万 TPS | ❌ 被挑战时需要高成本证明 |
| ✅ 支持 1 亿账户（SMT 可扩展） | ❌ 需要 RW log 机制 |
| ✅ 经济激励机制完善 | |
| ✅ 成本比 Validity 模式低 3890 倍 | |

#### 资源需求

| 资源 | 需求 | 说明 |
|------|------|------|
| Sequencer CPU | 32+ 核 | 执行交易 |
| RPC CPU | 64 核 | 同步 + SMT 更新 |
| 内存 | 256+ GB | 状态缓存 + SMT 树 |
| 存储 | 2+ TB SSD | SMT 树持久化 |
| 网络 | 1 Gbps | 区块同步 |
| Prover (备用) | 10-20 台 | 被挑战时使用 |

---

### 3.3 方案 C: State Diff Commitment

**核心思想**：不是完整 MPT，只对交易涉及的状态做承诺。

```
区块结构:
┌─────────────────────────────────────────────────────────────────┐
│ Block N                                                         │
│  ├── prev_hash                                                  │
│  ├── transactions[]                                             │
│  ├── state_diff_root  ← 新增：涉及状态的 Merkle root            │
│  └── output_hash                                                │
└─────────────────────────────────────────────────────────────────┘

State Diff:
┌─────────────────────────────────────────────────────────────────┐
│ diff = [                                                        │
│   { addr: A, key: balance, prev: 1000, new: 900 },              │
│   { addr: B, key: balance, prev: 500, new: 600 },               │
│ ]                                                               │
│                                                                 │
│ state_diff_root = merkle_root(diff)                             │
└─────────────────────────────────────────────────────────────────┘
```

#### 性能评估（1 万 TPS）

```
每区块 1000 笔交易:
  - 假设每笔交易涉及 2 个账户
  - State diff 大小: 1000 × 2 = 2000 条记录
  - Merkle tree 深度: log2(2000) ≈ 11 层
  - 计算开销: 2000 × 11 × hash = 22,000 次哈希

对比完整 MPT:
  - MPT 更新: 1000 × 20 = 20,000 次哈希 (类似)
  - 但 state diff 结构更简单，常数因子更小
```

#### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 比 MPT 开销小 | ❌ 仍需每区块构建 Merkle 树 |
| ✅ 支持传统 Fault Proof | ❌ diff 大小随交易复杂度增长 |
| ✅ 不依赖 ZK | ❌ 终局性延迟长 (7 天) |
| | ❌ **10 万 TPS 下性能不足** |

---

## 4. 推荐方案

### 4.1 针对 10 万 TPS + 1 亿账户的推荐

| 方案 | 终局性 | 每日成本 | 适合场景 | 推荐度 |
|------|--------|---------|---------|--------|
| **B: Fault Proof + 异步 SMT** | 7 天 | ~$8,640 | 高性能 + 大规模 + 成本敏感 | ⭐⭐⭐⭐⭐ **推荐** |
| **A: 纯 ZK (Validity)** | 3-5 分钟 | ~$33.6M | 不推荐（成本太高） | ❌ |
| **C: State Diff** | 7 天 | 低 | 不推荐（性能不足） | ❌ |

**为什么推荐方案 B？**

```
成本对比:
┌─────────────────────────────────────────────────────────────────┐
│ 方案 A (Validity): 每 batch 都生成 ZK proof                      │
│   - 每笔证明成本: $0.00038909                                    │
│   - 每 batch (1 亿笔): $38,910                                   │
│   - 每天 (864 batch): $33,600,000 ❌                             │
│                                                                 │
│ 方案 B (Fault Proof): 正常情况不生成 ZK proof                    │
│   - 正常情况: 只有 L1 提交成本                                   │
│   - 每天: $8,640 ✅                                              │
│   - 被挑战时: ~$38,910/batch (极少发生)                          │
│                                                                 │
│ 节省: 3890 倍 ✅                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 方案 B 具体参数建议

```
方案 B (Fault Proof + 异步 SMT) 配置:
┌─────────────────────────────────────────────────────────────────┐
│ 出块配置:                                                       │
│   - 出块速度: 0.1 秒/区块                                        │
│   - 每区块交易: 10,000 笔                                        │
│   - TPS: 100,000                                                │
│   - 出块时: 不做 SMT，只做 KV 更新 + RW log                      │
│                                                                 │
│ Batch 配置:                                                     │
│   - 批量大小: 1000 区块 (100 秒)                                │
│   - 每 batch 交易: 100 万笔                                     │
│   - SMT 更新: 异步，~16-32 秒 (16 核)                           │
│   - 涉及账户: ~200 万 (去重后)                                  │
│                                                                 │
│ L1 提交配置 (正常情况):                                          │
│   - 提交频率: 每 100 秒一次                                     │
│   - 每次提交: output_hash + smt_root (无 ZK proof!)              │
│   - Gas 成本: ~200k gas / batch                                │
│   - 每小时: 36 次提交                                           │
│   - 挑战期: 7 天                                                │
│                                                                 │
│ 被挑战时 (极少):                                                 │
│   - 生成 ZK proof                                               │
│   - 证明时间: ~5-10 分钟                                         │
│   - 证明成本: ~$38,910/batch                                    │
│                                                                 │
│ 终局性:                                                         │
│   - 延迟: 7 天 (挑战期)                                          │
│                                                                 │
│ 硬件需求:                                                       │
│   - Sequencer: 32+ 核, 128 GB 内存                              │
│   - RPC 节点: 64 核, 256 GB 内存, 2 TB SSD                      │
│   - Prover (备用): 10-20 台 (被挑战时使用)                       │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 完整架构图

```
执行层（热路径，0.1s 出块）
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│   │   Block N   │ →  │  Block N+1  │ →  │  Block N+2  │ → ...  │
│   │  0.1s/10ktx │    │  0.1s/10ktx │    │  0.1s/10ktx │        │
│   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘        │
│          │                  │                  │                │
│          ▼                  ▼                  ▼                │
│   ┌──────────┐      ┌──────────┐      ┌──────────┐            │
│   │ 执行交易  │      │ 执行交易  │      │ 执行交易  │            │
│   │ 更新 KV  │      │ 更新 KV  │      │ 更新 KV  │            │
│   │ 记录RWlog│      │ 记录RWlog│      │ 记录RWlog│            │
│   └──────┬───┘      └──────┬───┘      └──────┬───┘            │
│          │                  │                  │                │
│          └──────────────────┼──────────────────┘                │
│                             │                                   │
│                    每 1000 区块打包 (100秒)                       │
│                             ▼                                   │
└────────────────────────────┼───────────────────────────────────┘
                             │
                             ▼
结算层（冷路径，异步）
┌─────────────────────────────────────────────────────────────────┐
│  1. 汇总 RW Log → touched_keys (~200 万账户)                     │
│  2. 异步更新 SMT (16 核, ~16-32 秒)                              │
│  3. 提交 L1: output_hash + smt_root (无 ZK proof!)              │
│  4. 等待 7 天挑战期                                              │
│                                                                 │
│  被挑战时 (极少):                                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  1. 生成 SMT Proofs (涉及账户)                            │  │
│  │  2. 生成 ZK Proof (~5-10 分钟)                            │  │
│  │  3. 提交 L1 验证                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────┼──────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         L1 (Ethereum)                           │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              Fault Proof Contract                        │  │
│  │                                                           │  │
│  │  正常情况 (99%+):                                         │  │
│  │    - 提交: output_hash + smt_root                        │  │
│  │    - 等待 7 天挑战期                                      │  │
│  │    - 无人挑战 → 自动确认                                  │  │
│  │    - Gas: ~200k / batch                                  │  │
│  │                                                           │  │
│  │  被挑战时 (<1%):                                          │  │
│  │    - Challenger 质押 bond                                │  │
│  │    - Proposer 提交 ZK proof                              │  │
│  │    - L1 验证: verify(proof, prev_smt_root, smt_root)     │  │
│  │    - 胜者获得对方 bond                                    │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
---

## 5. 参考资料

### 5.1 ZK 证明系统

- [SP1](https://github.com/succinctlabs/sp1) - Succinct 的通用 zkVM
- [Risc0](https://github.com/risc0/risc0) - RISC-V zkVM
- [op-succinct](https://github.com/succinctlabs/op-succinct) - Optimism 的 ZK 方案

### 5.2 Fault Proof 系统

- [Optimism Fault Proof](https://docs.optimism.io/stack/protocol/fault-proofs/explainer)
- [Arbitrum Nitro](https://docs.arbitrum.io/inside-arbitrum-nitro)
- [op-succinct Fault Proof Mode](https://docs.succinct.xyz/op-succinct/fault-proofs/architecture)

### 5.3 状态承诺

- [Ethereum MPT](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
- [Sparse Merkle Tree](https://medium.com/@kelvinfichter/sparse-merkle-trees-explained-f41e6cbb2d6b)
- [Verkle Trees](https://ethereum.org/en/roadmap/verkle-trees/)
